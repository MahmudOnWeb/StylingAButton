<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ComputerFont" xml:space="preserve">
    <value>Police</value>
  </data>
  <data name="ComputerFontContent" xml:space="preserve">
    <value>Une police informatique (ou police) est un fichier de données numériques, contenant un ensemble de glyphes, caractères ou symboles liés graphiquement. Bien que le terme police se soit référé pour la première fois à un ensemble de pièces de type métal mobiles dans un style et une taille, depuis environ les années 1990, il est généralement utilisé pour désigner un ensemble de formes numériques dans un style unique, évolutif à différentes tailles.
Une définition de Microsoft décrit la police comme «une conception graphique appliquée à une collection de chiffres, symboles et caractères qui décrit une certaine police de caractères, ainsi que d'autres qualités telles que la taille, l'espacement et la hauteur».

Il existe trois types de base de formats de données de fichiers de polices informatiques: les polices bitmap, les polices vectorielles ou de contour et les polices de contour.

Les polices de contour ou les polices vectorielles sont une collection d'images vectorielles, composées de lignes et de courbes définissant la frontière des glyphes. Les premières polices vectorielles étaient utilisées par les moniteurs vectoriels et les traceurs vectoriels utilisant leurs propres polices internes, généralement avec des traits simples fins au lieu de glyphes épais. L'avènement de la PAO a amené la nécessité d'une norme universelle pour intégrer l'interface utilisateur graphique des premières imprimantes Macintosh et laser. La norme universelle était (et est toujours) Adobe PostScript. Des exemples de polices de contour incluent les polices PostScript Type 1 et Type 3, TrueType, OpenType.

TrueType est un standard de police de contour développé par Apple à la fin des années 1980.
OpenType est un format pour les polices informatiques évolutives. Il a été construit sur son prédécesseur TrueType, conservant la structure de base de TrueType et ajoutant de nombreuses structures de données complexes pour prescrire le comportement typographique. OpenType est une marque déposée de Microsoft Corporation.</value>
  </data>
  <data name="ComputingButton" xml:space="preserve">
    <value>Bouton</value>
  </data>
  <data name="ComputingButtonContent" xml:space="preserve">
    <value>Le terme bouton en informatique, également appelé bouton de commande, fait référence à un élément de contrôle graphique qui fournit à l'utilisateur un moyen simple d'interagir avec le système. Microsoft donne la définition suivante d'un bouton: "Un élément graphique qui ressemble à un bouton physique ou à une touche de clavier dans l'interface utilisateur. Un bouton est" enfoncé "en cliquant dessus avec une souris, en appuyant sur Entrée ou Espace sur le clavier, si le bouton est mis au point, ou en tapotant avec un doigt (si l'écran le prend en charge). "

Un bouton typique est un rectangle, plus large que haut, avec une légende descriptive en son centre. La méthode la plus courante pour appuyer sur un bouton est de cliquer dessus avec un pointeur contrôlé par une souris, mais d'autres entrées telles que les frappes peuvent également être utilisées. Un bouton n'est cependant pas limité à une forme rectangulaire. La seule exigence de l'interaction des boutons est que l'utilisateur puisse exécuter une commande par action de clic.</value>
  </data>
  <data name="Next" xml:space="preserve">
    <value>Suivant</value>
  </data>
  <data name="WritingSystem" xml:space="preserve">
    <value>Système d’écriture</value>
  </data>
  <data name="WritingSystemContent" xml:space="preserve">
    <value>Un système d'écriture (ou script) est une méthode de représentation visuelle de la communication verbale. Bien que l'écriture et la parole soient utiles pour transmettre des messages, l'écriture diffère en étant également une forme fiable de stockage et de transfert d'informations.

Plusieurs approches ont été adoptées pour classer les systèmes d'écriture, la plus courante et la plus élémentaire étant une large division en trois catégories: logographique, syllabique et alphabétique. Cependant, tous les trois peuvent être trouvés dans un système d'écriture donné dans des proportions variables, ce qui rend souvent difficile la catégorisation unique d'un système. Les types de systèmes d'écriture nationaux prédominants sont les suivants: alphabétique - par exemple, scripts latins et cyrilliques, logographiques et syllabiques, comme hanzi, kana, hangul, abjad - comme l'arabe et l'hébreu, et comme les scripts indic du nord et du sud du genre abugida, script éthiopique.</value>
  </data>
</root>