<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ComputerFont" xml:space="preserve">
    <value>글꼴</value>
  </data>
  <data name="ComputerFontContent" xml:space="preserve">
    <value>컴퓨터 글꼴 (또는 글꼴)은 그래픽 관련 글리프, 문자 또는 기호 집합을 포함하는 디지털 데이터 파일입니다. 폰트라는 용어는 처음에는 하나의 스타일과 크기로 움직일 수있는 금속 유형 조각 세트를 지칭했지만, 1990 년 대경부터 일반적으로 다른 크기로 확장 가능한 단일 스타일의 디지털 모양 세트를 나타내는 데 사용됩니다.
Microsoft의 정의는 글꼴을 "크기, 간격 및 피치와 같은 다른 품질과 함께 특정 서체를 설명하는 숫자, 기호 및 문자 모음에 적용되는 그래픽 디자인"으로 설명합니다.

컴퓨터 글꼴 파일 데이터 형식에는 비트 맵 글꼴, 벡터 또는 윤곽선 글꼴 및 획 글꼴의 세 가지 기본 종류가 있습니다.

아웃 라인 글꼴 또는 벡터 글꼴은 글리프의 경계를 정의하는 선과 곡선으로 구성된 벡터 이미지 모음입니다. 초기 벡터 글꼴은 일반적으로 두꺼운 외곽선 모양 대신 얇은 단일 선으로 자체 내부 글꼴을 사용하는 벡터 모니터 및 벡터 플로터에서 사용되었습니다. 데스크탑 출판의 출현으로 최초의 Macintosh 및 레이저 프린터의 그래픽 사용자 인터페이스를 통합하기위한 범용 표준이 필요했습니다. 보편적 인 표준은 Adobe PostScript였습니다. 개요 글꼴의 예로는 PostScript Type 1 및 Type 3 글꼴, TrueType, OpenType이 있습니다.

TrueType은 1980 년대 후반 Apple에서 개발 한 개요 글꼴 표준입니다.
OpenType은 확장 가능한 컴퓨터 글꼴 형식입니다. 그것은 이전의 TrueType을 기반으로 만들어졌으며 TrueType의 기본 구조를 유지하고 인쇄상의 행동을 처방하기 위해 많은 복잡한 데이터 구조를 추가했습니다. OpenType은 Microsoft Corporation의 등록 상표입니다.</value>
  </data>
  <data name="ComputingButton" xml:space="preserve">
    <value>단추</value>
  </data>
  <data name="ComputingButtonContent" xml:space="preserve">
    <value>컴퓨팅에서 버튼 (명령 버튼이라고도 함)이라는 용어는 시스템과 상호 작용하는 간단한 방법을 사용자에게 제공하는 그래픽 제어 요소를 나타냅니다. Microsoft는 다음과 같은 버튼 정의를 제공합니다. "사용자 인터페이스에서 물리적 버튼 또는 키보드 키와 유사한 그래픽 요소. 마우스로 버튼을 클릭하거나 키보드에서 Enter 또는 Space를 눌러 버튼을"눌렀습니다. " 버튼에 초점이 있거나 손가락으로 두드리면 (디스플레이가 지원하는 경우) "

일반적인 버튼은 키보다 큰 직사각형이며 중앙에 설명 캡션이 있습니다. 버튼을 누르는 가장 일반적인 방법은 마우스로 제어되는 포인터로 버튼을 클릭하는 것이지만 키 입력과 같은 다른 입력도 사용할 수 있습니다. 그러나 버튼은 직사각형으로 제한되지 않습니다. 버튼 상호 작용의 유일한 요구 사항은 사용자가 클릭 동작으로 명령을 실행할 수 있어야한다는 것입니다.</value>
  </data>
  <data name="Next" xml:space="preserve">
    <value>다음</value>
  </data>
  <data name="WritingSystem" xml:space="preserve">
    <value>쓰기 시스템</value>
  </data>
  <data name="WritingSystemContent" xml:space="preserve">
    <value>작문 시스템 (또는 스크립트)은 구두 의사 소통을 시각적으로 표현하는 방법입니다. 쓰기와 말하기는 메시지를 전달하는 데 유용하지만 쓰기는 신뢰할 수있는 정보 저장 및 전송 형식이 다릅니다.

쓰기 시스템을 분류하기위한 몇 가지 접근 방식이 채택되었으며, 가장 일반적이고 기본적인 방법은 3 가지 범주 (로그 로지, 음절 및 알파벳)로 크게 구분됩니다. 그러나 3 가지 시스템 모두 주어진 쓰기 시스템에서 다양한 비율로 발견 될 수 있으므로 시스템을 고유하게 분류하기가 어려운 경우가 많습니다. 주요 국가 유형의 필기 시스템은 다음과 같습니다. 알파벳-예를 들어 라틴어 및 키릴 문자 스크립트, 한자, 가나, 한글, abjad-아랍어 및 히브리어와 같은 로그 및 음절, 북쪽 및 남쪽 인도어 스크립트, 에티오피아 문자.</value>
  </data>
</root>